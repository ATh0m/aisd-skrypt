\section{Algorytm rosyjskich wieśniaków}

Algorytm rosyjskich wieśniaków jest przypisywany sposobowi mnożenia liczb używanemu w XIX-wiecznej Rosji.
Aktualnie jest on stosowany w niektórych układach mnożących.
\comment{Zawile napisane.
Dodać przykład.
Napisać, że to analog mnożenia pisemnego w systemie binarnym.}
Aby pomnożyć liczby $a$ i $b$ tworzymy dwukolumnową tabelę.
Wartości $a$ i $b$ zapisujemy w jej nagłówku (pierwszym wierszu).
W kolejnych wierszach wpisujemy $\lfloor\frac{a'}{2}\rfloor$ i $2 \cdot b'$, gdzie $a'$ i $b'$ to wartości z wiersza powyżej. 
Czynność tą wykonujemy, aż uzyskamy $1$ w kolumine pod $a$. 
Ostatnim krokiem jest zsumowanie wartości z kolumny pod $b$ z tych wierszy dla których wartości w kolumine pod $a$ są nieparzyste.
Uzyskany w ten sposób wynik jest równy $a \cdot b$.

\begin{algorithm}[h]
  \DontPrintSemicolon
  \SetAlgorithmName{Algorytm}{}
  
  \KwData{ $a$, $b$ - liczby naturalne }
  
  \KwResult{ $wynik = a \cdot b$ }
  
  $a' \leftarrow a$\;
  $b' \leftarrow b$\;
  $wynik \leftarrow 0$\;
  \While{\upshape $a' > 0$}
  {
    \If{\upshape $a' \textsf{ mod } 2 = 1$}
    {
      $wynik \leftarrow wynik + b'$\;
    }
    $a' \leftarrow a' \textsf{ div } 2$\;
    $b' \leftarrow b' \cdot 2$\;
  }
  
  \caption{Algorytm rosyjskich wieśniaków}
  \label{alg-wiesniakow}
\end{algorithm}

\comment{Jakiś wstęp, do czego służy algorytm, przykład działania, analogia między algorytmem a algorytmem szybkiego potęgowania.
Dowód poprawności jako jakieś twierdzenie / lemat.
Popracować nad składaniem latexa.}
Niech $a'_i$ (kolejno: $b'_i$, $wynik_i$) będzie wartością zmiennych \texttt{a'} (\texttt{b'}, \texttt{wynik}) w $i-tej$ iteracji pętli \texttt{while}. 
Udowodnimy następujący niezmiennik:
\[
a'_i \cdot b'_i + wynik_i = a \cdot b \enspace.
\]
Załóżmy, że niezmiennik zachodzi w $i-tej$ iteracji i sprawdźmy co dzieje się w $i+1$ iteracji.
Rozważmy dwa przypadki.


\begin{itemize}
    \item $a'_i$ parzyste. Instrukcja \texttt{if} się nie wykona, w $i+1$ iteracji $wynik_i$ pozostanie niezmieniony, $a'_i$ zmniejszy się o połowę, a $b'_i$ zwiększy dwukrotnie. 
    \[
      wynik_{i+1} = wynik_i
    \]
    \[
      a'_{i+1} = a'_i \textsf{ div } 2 = \frac{a'_i}{2}
    \]
    \[
      b'_{i+1} = b'_i \cdot 2
    \]
    W tym przypadku otrzymujemy:
    \[
      a'_{i+1} \cdot b'_{i+1} + wynik_{i+1} = \frac{a'_i}{2} \cdot 2 b'_i + wynik_i = a'_i \cdot b'_i + wynik_i = a \cdot b
    \]

    \item $a'_i$ nieparzyste:
    \[
      wynik_{i+1} = wynik_i + b'_i
    \]
    \[
      a'_{i+1} = a'_i \textsf{ div } 2 = \frac{a'_i-1}{2}
    \]
    \[
      b'_{i+1} = b'_i \cdot 2
    \]
    Ostatecznie otrzymujemy:
    \[
      a'_{i+1} \cdot b'_{i+1} + wynik_{i+1} = \frac{a'_i-1}{2} \cdot 2 b'_i + wynik_i +b'_i = a'_i \cdot wynik_i + b'_i= a \cdot b
    \]

\end{itemize}

Teraz wystarczy zauważyć, że tuż po wyjściu z pętli \texttt{while} wartość zmiennej $a'$ wynosi $0$.
Podstawiając do niezmiennika okazuje się, że faktycznie algorytm rosyjskich wieśniaków liczy $a \cdot b$.

\paragraph{Złożoność}

Z każdą iteracją połowimy $a'$. 
Biorąc pod uwagę kryterium jednorodne pozostałe instrukcje w pętli nic nie kosztują. 
Stąd złożoność to $O(\log a)$.

W kryterium logarytmicznym musimy uwzględnić czas dominującej instrukcji: dodawania  $wynik \leftarrow wynik + b'$. 
W najgorszym przypadku zajmuje ono $O(\log ab)$. Zatem złożoność to $O(\log a \cdot \log ab)$.

